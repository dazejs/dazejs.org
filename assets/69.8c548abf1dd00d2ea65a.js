(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[69],{

/***/ 526:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("# 自动加载\n\n`Daze.js` 会自动扫描 `src/app` 目录，按功能分类加载，我们可以通过不用的类型装饰器来表示\n\n---\n\n## 模块分类\n### 控制器类\n\n使用 `@controller()` 装饰器\n\n```ts\nimport { controller } from '@daze/framework'\n\n@controller('/example')\nexport class Example{\n  // ...\n}\n\n```\n\n> 同时提供了大写的别名 `@Controller()`\n\n### 中间件类\n使用 `@middleware()` 装饰器\n\n```ts\nimport { middleware, MiddlewareInterface } from '@daze/framework'\n\n@middleware('example-middleware')\nexport class Example implements MiddlewareInterface {\n  resolve(request, next) {\n    // ...\n    return next()\n  }\n}\n\n```\n> 中间件类需要实现 `MiddlewareInterface` 接口\n> 同时提供了大写的别名 `@Middleware()`\n\n### 服务类\n\n使用 `@service()` 装饰器\n\n```ts\nimport { service } from '@daze/framework'\n\n@service('exampleService')\nexport class Example {\n  // ...\n}\n```\n\n> 同时提供了大写的别名 `@Service()`\n\n### 验证器类\n\n使用 `@validator()` 装饰器\n\n```ts\nimport { validator, isEmail } from '@daze/framework'\n\n@validator('exampleValidator')\nexport default class Example {\n  @isEmail()\n  email: string;\n}\n```\n\n> 同时提供了大写的别名 `@Validator()`\n\n### 资源类\n\n使用 `@resource()` 装饰器\n\n```ts\nimport { resource, ResourceInterface } from '@daze/framework'\n\n@resource('exampleResource')\nexport class Example implements ResourceInterface {\n  // ...\n}\n\n```\n\n> 资源类需要实现 `ResourceInterface` 接口\n> 同时提供了大写的别名 `@Resource()`\n\n### 通用类\n\n```ts\nimport { component } from '@daze/framework'\n\n@component('exampleComponent')\nexport class Example {\n  // ...\n}\n\n```\n\n> 同时提供了大写的别名 `@Component()`\n\n---\n\n## 忽略加载\n\n有时候我们不希望自动加载机制加载某个模块，可以使用 `@ignore` 标识\n\n```ts\nimport { ignore } from '@daze/framework'\n\n@ignore\nexport class Example {\n  // ...\n}\n```\n\n> 同时提供了大写的别名 `@Ignore`\n\n---\n\n## 模块命名\n\n使用框架提供的 `@service()`, `@component()`, `@validator()`, `@resource()` 等装饰器来为模块进行重命名操作（实际上增加了绑定到容器的 `key`）。\n\n```ts\nimport { service } from '@daze/framework'\n\n@service('exampleService')\nexport class Example {\n  sayHello() {\n    return 'hello dazejs';\n  }\n}\n```\n\n**默认名称**\n\n默认使用 `class` 的名称的小驼峰\n\n默认绑定名字 `exampleService`\n```ts\nimport { service } from '@daze/framework'\n\n@service()\nexport class ExampleService {\n  sayHello() {\n    return 'hello dazejs';\n  }\n}\n```\n\n自动识别变量名进行注入 (根据注入的变量名找到自定义的模块名称进行注入)\n\n```ts {5}\nimport { controller, http, inject } from '@dazejs/framework';\nimport ExampleService from '../service/example'\n\n@controller('/examples')\nexport default class Example {\n  @inject() \n  exampleService: ExampleService;\n\n  @http.get()\n  index() {\n    return this.exampleService.sayHello()\n  }\n}\n```\n\n> 依赖注入详见 [依赖注入](#/docs/core/di) 章节");

/***/ })

}]);