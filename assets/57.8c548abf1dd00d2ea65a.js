(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[57],{

/***/ 514:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("# 控制器\n\n控制器负责处理传入的请求，并返回对客户端的响应。\n\n---\n\n## 定义\n\n控制器使用装饰器 `@controller()`\n\n```ts {3}\nimport { controller } from '@dazejs/framework'\n\n@controller()\nexport default class User {\n  // ...\n}\n\n```\n\n---\n\n## 控制器增强\n\n框架提供了 `BaseController` 基类来增强控制器的功能\n\n```ts {3}\nimport { controller, BaseController } from '@dazejs/framework'\n\n@controller()\nexport default class User extends BaseController {\n  // ...\n}\n\n```\n\n如果继承了 `BaseController`，那么我们就可以使用基类提供的许多便捷方法\n\n\n```ts {3}\nimport { controller, BaseController } from '@dazejs/framework'\n\n@controller()\nexport default class User extends BaseController {\n  @http.het()\n  index() {\n      // this.request.getParams()\n      // this.config.get('app.port')\n      // this.db().table('users').find()\n      // 等等...\n  }\n}\n\n```\n---\n\n## 定义路由\n\n控制器使用 `@controller([prefix])` 装饰器来表示该控制器使用了路由功能\n\n```ts\nimport { controller } from '@dazejs/framework'\n\n// 当前控制器的端点访问以 '/users' 开头 (可省略开头 '/')\n@controller('/users')\nexport default class {\n  // ...\n}\n```\n\n框架提供了 `get`, `post`, `put`,`patch`,`del`,`head`,`option`, `all` 装饰器（位于 `http` 命名空间下），用于创建访问路由：\n\n```ts\nimport { controller, http } from '@dazejs/framework'\n\n// 当前控制器的端点访问以 '/users' 开头 (可省略开头 '/')\n@controller('users')\nexport class User {\n    // get /users\n    @http.het()\n    index() {\n        // ...\n    }\n\n    // put /users/:id\n    @http.put(':id')\n    update(id) {\n        // ...\n    }\n}\n```\n\n上面代码会自动创建`get`方法访问的`/users`的端点与`put`方法访问的`/users/:id`的端点\n\n> `@http.all` 装饰器会使用所有 `http` 模块支持的方法，详细信息见 `http` 模块的 `http.METHODS` 属性\n\n\n### 路由多前缀\n\n在某些情况下，我们可能需要支持一个控制器多个路由前缀的情况\n\n```ts\nimport { controller, http } from '@dazejs/framework'\n\n// 通过添加多个 `@route` 参数来注册多个前缀的路由\n@controller('/users', '/users-old')\nexport default class User {\n    // get /users\n    @http.get()\n    index() {\n        // ...\n    }\n\n    // put /users/:id\n    @http.put(':id')\n    update(id) {\n        // ...\n    }\n}\n```\n\n### 方法多路由\n\n\n在某些情况下，我们也可能需要同一个控制器方法支持多个路由访问\n\n\n```ts\nimport { controller, http } from '@dazejs/framework'\n\n@controller('/users')\nexport class User {\n    @http.get()\n    @http.post('/post')\n    index() {\n        // ...\n    }\n\n    @http.all('/all', ['get', 'post']) // 第二个参数可选，默认加载http所有method（不推荐）\n    index2() {\n        // ...\n    }\n}\n```\n\n\n---\n\n## 路由参数\n\n路由的参数框架会自动注入到控制器方法中：\n\n```ts\nimport { controller, http } from '@daze/framework';\n\n@controller()\nexport class User {\n    @http.get('/:name/:age')\n    index(name, age) {\n        // ...\n    }\n}\n```\n\n> 路由参数根据定义顺序注入\n\n\n\n---\n\n## REST 风格\n\n使用 `@rest` 装饰器代替 `@route` 装饰器，并且默认 `Rest` 方法无需添加装饰器:\n\n```ts\nimport { rest } from '@daze/framework';\n\n@rest('posts')\nexport class Post {\n   /**\n   * Display a listing of the resource.\n   */\n  index() {\n    //\n  }\n\n  /**\n   * Show the form for creating a new resource.\n   */\n  create() {\n    //\n  }\n\n  /**\n   * Display the specified resource.\n   * @param {number} id\n   */\n  show(id) {\n    //\n  }\n\n  /**\n   * Show the form for editing the specified resource.\n   * @param {number} id\n   */\n  edit(id) {\n    //\n  }\n\n  /**\n   * Store a newly created resource in storage.\n   */\n  store() {\n    //\n  }\n\n  /**\n   * Update the specified resource in storage.\n   * @param {number} id\n   */\n  update(id) {\n    //\n  }\n\n  /**\n   * Remove the specified resource from storage.\n   * @param {number} id\n   */\n  destroy(id) {\n    //\n  }\n}\n```\n\n内置 `Rest` 风格方法：\n\n| 请求类型 | 资源地址        | 控制器方法 | 说明             |\n| -------- | --------------- | ---------- | ---------------- |\n| get      | /posts          | index()      | 索引/列表        |\n| get      | /posts/create   | create()     | 创建（显示表单)  |\n| post     | /posts          | store()      | 保存你创建的数据 |\n| get      | /posts/:id      | show(id)       | 获取对应id的内容 |\n| get      | /posts/:id/edit | edit(id)       | 编辑（显示表单） |\n| put      | /posts/:id      | save(id)       | 保存你编辑的数据 |\n| delete   | /posts/:id      | destroy(id)    | 删除对应id的内容 |\n\n---\n\n## 路由原理\n\n### 路由结构\n\n`Daze.js` 采用了类似前缀树的数据结构来存储路由，例如我们有一个 `path`: `/business/users/posts/:post_id`, 那么它的结构就是一个链表:\n\n```text\n+----------+     +-----------+     +-------+     +----------+\n| business | --> |   users   | --> | posts | --> | :post_id |\n+----------+     +-----------+     +-------+     +----------+\n```\n\n接下来如果继续注册 `/business/orders/:order_id`, 那么这个结构就会变成\n\n\n```text\n+----------+     +-----------+     +-------+     +----------+\n| business | --> |   users   | --> | posts | --> | :post_id |\n+----------+     +-----------+     +-------+     +----------+\n  |\n  |\n  v\n+----------+     +-----------+\n|  orders  | --> | :order_id |\n+----------+     +-----------+\n```\n\n### 路由类型\n\n为了增加匹配的性能，我们将路由分成了三种类型 `静态类型`, `正则类型`, `全匹配类型`\n\n**静态类型**\n\n静态类型就是指字符串完全匹配的类型，避免所有节点都需要正则匹配，降低性能\n\n**正则类型**\n\n只有注册了路由参数/正则的节点才会进行正则匹配\n\n**全匹配类型**\n\n全匹配类型是指以 `/*` 结尾的路由，它可以匹配后续任何参数\n\n### 路由优先级\n\n框架会自动为注册的路由指定优先级，优先级策略如下：\n\n- 节点经过次数最多的路由，优先级最高\n- 全匹配路由优先级最低，为了保证不会因为全匹配路由覆盖了其他类型的路由\n\n\n\n");

/***/ })

}]);